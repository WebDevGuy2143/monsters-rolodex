{"version":3,"sources":["components/card/card.component.jsx","components/card-list/card-list.component.jsx","components/search-box/search-box.component.jsx","App.js","serviceWorker.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsters","map","key","SearchBox","placeholder","handleChange","App","e","setState","searchField","target","value","state","fetch","then","response","json","users","this","filteredMonsters","filter","toLowerCase","includes","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"6UAOaA,G,MAAO,SAAAC,GAAK,OACrB,yBAAKC,UAAU,kBACf,yBAAKC,IAAI,UAAUC,IAAG,+BAA0BH,EAAMI,QAAQC,GAAxC,4BACtB,gCAAOL,EAAMI,QAAQE,KAArB,KACA,+BAAMN,EAAMI,QAAQG,MAApB,QCDSC,G,MAAW,SAAAR,GAAK,OAGzB,yBAAKC,UAAU,aAGdD,EAAMS,SAASC,KAAI,SAAAN,GAAO,OAGvB,kBAAC,EAAD,CAAMO,IAAKP,EAAQC,GAAID,QAASA,UCZ3BQ,G,MAAY,SAAC,GAAD,EAAGC,YAAH,EAAgBC,eCgF1BC,G,wDAvEb,aAAe,IAAD,8BAGZ,gBA4BFD,aAAe,SAACE,GACd,EAAKC,SAAS,CAAEC,YAAaF,EAAEG,OAAOC,SA1BtC,EAAKC,MAAQ,CAGXZ,SAAU,GAGVS,YAAa,IAZH,E,gEAiBM,IAAD,OAGjBI,MAAM,8CAGLC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAI1BF,MAAK,SAAAG,GAAK,OAAI,EAAKT,SAAS,CAAER,SAAUiB,S,+BASlC,MAI0BC,KAAKN,MAA/BZ,EAJA,EAIAA,SAAUS,EAJV,EAIUA,YAIXU,EAAmBnB,EAASoB,QAAO,SAAAzB,GAAO,OAAIA,EAAQE,KAAKwB,cAAcC,SAASb,EAAYY,kBAGpG,OAGE,yBAAK7B,UAAU,OAGf,gDAKE,kBAAC,EAAD,CAAWY,YAAY,kBAAkBC,aAAca,KAAKb,eAG5D,kBAAC,EAAD,CAAUL,SAAUmB,S,GAhEVI,cCDEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBtB,MAAK,SAAAuB,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.5f71bbf6.chunk.js","sourcesContent":["/* imports the React libray */\r\nimport React from 'react';\r\n\r\n/* import card styles */\r\nimport './card.styles.css';\r\n\r\n/* pass in each property for each monster from the monsters array through props \"each\" monster for Card */\r\nexport const Card = props => (\r\n    <div className='card-container'>\r\n    <img alt=\"monster\" src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`} />\r\n    <h2> { props.monster.name } </h2>\r\n    <p> { props.monster.email } </p>\r\n    </div>\r\n)","/* imports the React libray */\r\nimport React from 'react';\r\n\r\n/* import Card.component from card directory */\r\nimport { Card } from '../card/card.component';\r\n\r\n/* import card-list-styles */\r\nimport './card-list.styles.css';\r\n\r\n/* export CardList and pass in props as a parameter */\r\nexport const CardList = props => (\r\n\r\n    /* returns a div of the css class name 'card-list' and passes the children method which means anything within the CardList component <CardList> */\r\n    <div className='card-list'> \r\n    \r\n    {/* creates a new array displaying each name in the monsters array within an h1 tag */}\r\n    {props.monsters.map(monster => (\r\n\r\n        /* creates html tag with the key from state property id and passes in the individual monster */\r\n        <Card key={monster.id} monster={monster} />\r\n      ))}\r\n      </div>\r\n);","/* imports the React libray */\r\nimport React from 'react';\r\n\r\n/* import search-box.styles from search-box directory */\r\nimport './search-box.styles.css';\r\n\r\n/* functional component that returns html */\r\nexport const SearchBox = ({ placeholder, handleChange }) => (\r\n\r\n    /* Search input and set the onChange event to get the value of what is typed in the search box\r\n    becuase setState is an asyc function, it will automatically run indefinetly, so in order to bypass this to only run when we type something in the search field, we must create an anonymous function */\r\n        <input className='search' type='search' placeholder={placeholder} onChange={handleChange}/>\r\n\r\n)","/* imports the React libray */\nimport React, { Component } from 'react';\n\n/* imports CardList variable from card-list.component.jsx */\nimport { CardList } from './components/card-list/card-list.component';\n\n/* imports SearchBox variable from search-box.component.jsx */\nimport { SearchBox } from './components/search-box/search-box.component';\n\n/* imports App.css */\nimport './App.css';\n\n/* defining App class displayed in index.js <App /> extending from the component class within the React library */\nclass App extends Component {\n\n  /* The constructor is a method thatâ€™s automatically called during the creation of an object from a class. It can handle your initial setup stuff like defaulting some properties of the object, or sanity checking the arguments that were passed in. Simply put, the constructor aids in constructing things. */\n  constructor() {\n\n    /* calls the constructor of the parent class */\n    super();\n\n    /* contains data from our monsters */\n    this.state = {\n\n      /* create empty monsters array */\n      monsters: [],\n\n      /* store data for search */\n      searchField: ''\n    };\n  }\n\n  /* define componentDidMount */\n  componentDidMount(){\n\n    /* which calls to the api users */\n    fetch('https://jsonplaceholder.typicode.com/users')\n\n    /* creates a response and passes the data into json objects */\n    .then(response => response.json())\n\n    /* sets the state which holds the empty monsters array\n    fills in the array with the data passed in from the api for users */\n    .then(users => this.setState({ monsters: users }));\n  }\n\n  /* define handleChange function */\n  handleChange = (e) => {\n    this.setState({ searchField: e.target.value });\n  }\n  \n  /* the process of transforming your react components into \"DOM Document Object Model\" nodes that your browser can understand and display on the screen */\n  render() {\n\n    /* destructure the state monsters, searchField by pulling the properties \n       equivilent to const monsters = this.state.monsters; and const searchField = this.state.searchField; */\n    const {monsters, searchField } = this.state;\n\n    /* set constant filteredMonsters to filter the monsters array by the filter function\n       get the monster name and make the results switch to lowercase in the search input */\n    const filteredMonsters = monsters.filter(monster => monster.name.toLowerCase().includes(searchField.toLowerCase()))\n\n    /* returns html markup */\n    return (\n\n      /* instead of just using class in React we use className and then assign a name ie. App, App-header, App-logo, App-link */\n      <div className=\"App\">\n\n    \n      <h1>Monsters Rolodex</h1>\n\n        {/* Search input and set the handleChange event from the search-box.component file to get the value of what is typed in the search box\n            becuase setState is an asyc function, it will automatically run indefinetly, so in order to bypass this to only run when we type something in the search field, we must create an anonymous function \n        */}\n        <SearchBox placeholder='Search Monsters' handleChange={this.handleChange} />\n\n        {/* creates new html tag for CardList variable. The CardList component receives the monsters jsx attribute and uses this attribute monsters as a 'prop' which is passed in as the value from the filteredMonsters constant variable*/}\n        <CardList monsters={filteredMonsters}>\n          \n\n        </CardList>\n      </div>\n    );\n  }\n}\n  \n/* export App class to designated file index.js */\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}